В предидущем курсе мы узнали что такое агрегаторные функции (это функции которые принимают множество значений и возвращают
одно).

Сейчас мы познакомимся с анализирующими функциями, которые тоже оперируют с множеством строк. Но, в отличае от агрегаторных
функций, анализирующие функции возвращают значение для каждой строки в таблице.

Анализирующие функции позволяют нам выполнять комплексные вычисления с довольно прямолинейным синтаксисом. Например, мы можем 
быстро вычислить скользящее среднее и промежуточную сумму среди других количеств.

Синтаксис 
Для понимания как писать аналитические функции, мы будем работать с маленькой таблицей содержащей данные о двух разных людях
тренирующихся для забега. Колонка id показывает нам на номер атлета, date показывает день когда произведен замер и time
показывает время в минутах которое уделил тренировке спортсмен. Вычисляем мы, например, скользящее среднее время тренировки
для каждого атлета, где мы берем среднее текущей и предыдущих тренировок. 
+===+==========+====+
|id |   date   |time|
+---+----------+----+
| 1 |2019-07-05| 22 |
+---+----------+----+
| 1 |2019-04-15| 26 |
+---+----------+----+
| 2 |2019-02-06| 28 |
+---+----------+----+
| 1 |2019-01-02| 30 |
+---+----------+----+
| 2 |2019-08-30| 20 |
+---+----------+----+
| 2 |2019-03-09| 22 |
+---+----------+----+

query = """
        SELECT *,
            AVG(time) OVER(
                            PARTITION BY id
                            ORDER BY date
                            ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
                           ) as avg_time
        FROM `bigquery-public-data.runners.train_time`
        """

Все аналитические функции имеют часть OVER, которое определяет множество строк которые будут использованны в каждом вычислении.
OVER имеет 3 (опциональные) части:
- PARTITION BY: делит строки таблицы на разные группы. В запросе выше мы разделяем их по id, так что вычесления разделены для
атлетов.
- ORDERR BY: определяет порядок внутри каждой группы. В запросе выше упорядочивая по дате мы заставляем более ранние тренировки
оказаться первыми.
- ROWS BETWEEN 1 PRECEDING AND CURRENT ROW: более известно как WINDOW FRAME. Оно определяет множество строк используемое в каждом
вычислении. Мы можем обращаться к этой группе строк как к ОКНУ (вообще иногда аналитические функции зовутся аналитические 
оконные функции или же просто оконные функции).

Существует множество способов писать window frame
- ROWS BETWEEN 1 PRECEDING AND CURRENT ROW  -- предыдущая и текущая строка
- ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING  -- 3 предыдущие строки, текущая и следующая строки.
- ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING  -- все строки в группе

3 вида аналитических функций.

1) Аналитически агрегаторные функции.
Как мы можем заметить, AVG() агрегаторная функция. OVER то что делает ее аналитической.
- MIN() MAX() - возвращает минимальное или максимальное значение среди строк поданых на вход
- AVG() SUM() - возвращает среднее или сумму значений.
- COUNT() - возвращает количество строк поданых на вход.

2) Аналитические навигационные функции 
Навигационные функции дают значение основываясь на значении в строках отличных от текущей.
- FIRST_VALUE() LAST_VALUE() -- возвращает первое или последнее значение на входе.
- LEAD() LAG()  --Эти функции возвращают значение выражения, вычисленного для предыдущей 
строки (LAG) или следующей строки (LEAD) результирующего набора соответственно. возвращает значение 

3) Аналитические нумерующие функции
- ROW_NUMBER() -- Функция ROW_NUMBER, как следует из ее названия, нумерует строки, возвращаемые запросом. (начинается с 1)
- RANK()  -- То же что и ROW_NUMBER, но все строки с одинаковыми значениями в порядковом столбце получают одно и тоже значение.